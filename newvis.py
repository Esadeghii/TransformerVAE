# # -*- coding: utf-8 -*-
# """newvis.ipynb

# Automatically generated by Colaboratory.

# Original file is located at
#     https://colab.research.google.com/drive/1d5YCH9ho79T6S-Sa4ofuJ2jm-6pTPFXN
# """

# # #@title Default title text
# # # !git clone https://github.com/mbonyani/VAE.git
# # !git clone https://github.com/mbonyani/VAEnew.git

# # # Commented out IPython magic to ensure Python compatibility.
# # # cd /content/VAE
# # # %cd /content/VAEnew

# pwd

import sys 
# sys.path.append()

# !pip install tensorboardX==2.2

# !python GenGrid.py

import math
import torch
import torch.nn as nn
import numpy as np 
import torch.nn.functional as F

model = torch.load("a0.003lds17b0.007g2d1DM24NH6st4dff128.pt")

from sequenceDataset import SequenceDataset
import pandas as pd
import numpy as np
dataset = SequenceDataset(datafile = './data-and-cleaning/cleandata_4Feb.csv')

sequences = dataset.dataset.loc[dataset.dataset["Wavelen"]>800,'Sequence']

#the OG alex onehot encoding 1 liner
oheSeqs = dataset.transform_sequences(sequences.apply(lambda x: pd.Series([c for c in x])).to_numpy())
# for n in range(0, 1):
# print("generated " + str(n))
SOS_token = np.ones((1,1,4))*2
EOS_token = np.ones((1,1,4))*3
seqs =  np.concatenate((SOS_token, np.expand_dims(oheSeqs[150], 0), EOS_token),axis=1)


output, _, _, _, _ = model(torch.from_numpy(seqs).long())

output.shape

sequences.shape

z = list(sequences.iloc[150].strip(""))

z

attn_logits_maps,attn_probs_maps = model.extract_maps(torch.from_numpy(seqs).long(),None,None)

a = attn_probs_maps[0][0:1]

a.shape

heatmap = a[0,0,1:11,1:11]

def convert_value(array):
  for i in range(array.shape[0]):
    max_index = np.argmax(array[i])  # Get the index of the maximum value in the row
    array[i][np.arange(array.shape[1]) != max_index] = 0  # Convert the other 

  return array

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# Create a graph object
G = nx.Graph()

# Define the number of nodes
matrix = np.round(heatmap.numpy(), decimals=2)
matrix = convert_value(matrix)
arr=matrix
num_nodes = arr.shape[0]
node_names = [z[i]+str(i) for i in range(10)]
# Add nodes to the graph
for i in range(num_nodes):
    # G.add_node(i+1)
    G.add_node(node_names[i])


# Add edges to the graph
for i in range(num_nodes):
    for j in range(num_nodes):
        if arr[i][j] > 0:
            # G.add_edge(i+1, j+1, weight=arr[i][j])
            G.add_edge(node_names[i], node_names[j], weight=arr[i][j])


# Draw the graph
pos = nx.spring_layout(G, seed=42)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw(G, pos, with_labels=True)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')
plt.show()



import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import cv2
# Create a graph object
def all_graph(heatmap):
  plt.close()
  G = nx.Graph()

  # Define the number of nodes
  matrix = np.round(heatmap.numpy(), decimals=2)
  matrix = convert_value(matrix)
  arr=matrix
  num_nodes = arr.shape[0]
  node_names = [z[i]+str(i) for i in range(10)]
  # Add nodes to the graph
  for i in range(num_nodes):
      # G.add_node(i+1)
      G.add_node(node_names[i])


  # Add edges to the graph
  for i in range(num_nodes):
      for j in range(num_nodes):
          if arr[i][j] > 0:
              # G.add_edge(i+1, j+1, weight=arr[i][j])
              G.add_edge(node_names[i], node_names[j], weight=arr[i][j])


  # Draw the graph
  pos = nx.spring_layout(G, seed=42)
  edge_labels = nx.get_edge_attributes(G, 'weight')
  nx.draw(G, pos, with_labels=True)
  nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')
  plt.savefig("./a.jpg",dpi=400)
  img = cv2.imread("./a.jpg")
  return img

heat=[]




for n in range(len(oheSeqs)):
# print("generated " + str(n))
  SOS_token = np.ones((1,1,4))*2
  EOS_token = np.ones((1,1,4))*3
  seqs =  np.concatenate((SOS_token, np.expand_dims(oheSeqs[n], 0), EOS_token),axis=1)
  z = list(sequences.iloc[n].strip(""))
  attn_logits_maps,attn_probs_maps = model.extract_maps(torch.from_numpy(seqs).long(),None,None)
  heatmap = attn_probs_maps[0][0:1]
  heatmap = heatmap[0,0,1:11,1:11]
  heat.append( all_graph(heatmap))


# plt.show()

fig=plt.figure(1,figsize=(15,400))
for i in range(30):
  kk = i%3
  fig.add_subplot(10,3,3*i+1+kk)
  plt.imshow(heat[i])
plt.savefig("./f.jpg",dpi=400)